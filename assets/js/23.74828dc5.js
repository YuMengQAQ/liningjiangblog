(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{411:function(t,i,a){"use strict";a.r(i);var s=a(10),e=Object(s.a)({},(function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("h1",{attrs:{id:"git"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git"}},[t._v("#")]),t._v(" Git")]),t._v(" "),a("h2",{attrs:{id:"git基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git基本操作"}},[t._v("#")]),t._v(" Git基本操作")]),t._v(" "),a("p",[t._v("查看版本库状态：\ngit status\n增加文件到暂存区：\t\ngit add test.txt")]),t._v(" "),a("p",[t._v('查看文件具体修改：\ngit diff test.txt\n增加文件到暂存区：\ngit add test.txt\n提交版本到分支：\ngit commit -m "change Git to git"\n可以再次查看状态：\ngit status')]),t._v(" "),a("ul",[a("li",[t._v("查看历史状态\n"),a("ul",[a("li",[a("p",[t._v("git is a version control system.")])]),t._v(" "),a("li",[a("p",[t._v("git is free software.")])]),t._v(" "),a("li",[a("p",[t._v("git is good.")])])])])]),t._v(" "),a("p",[t._v('增加文件到暂存区：\ngit add test.txt\n提交版本到分支：\ngit commit -m "add new line git is good"')]),t._v(" "),a("p",[t._v("...重复以上步骤保存文件的多个版本...")]),t._v(" "),a("h2",{attrs:{id:"查看历史版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看历史版本"}},[t._v("#")]),t._v(" 查看历史版本：")]),t._v(" "),a("p",[t._v("​    git log\n​    或\n​    git log --pretty=oneline")]),t._v(" "),a("h2",{attrs:{id:"回滚版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回滚版本"}},[t._v("#")]),t._v(" 回滚版本")]),t._v(" "),a("p",[t._v("​    git reset --hard HEAD^\n在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD ^ ^ ，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\t\n也可以通过版本包跳转版本，比上一种写法好的地方在于可以跳转到已经被回退的版本上:\n​    git reset --hard 5527510751b4303390bb4f321bfa8b7f997cbfd0\n​    或简写为\n​    git reset --hard 55275\n但是问题是如知道版本号呢？可以通过如下命令查看之前所有提交对应操作及版本号：\n​    git reflog")]),t._v(" "),a("h2",{attrs:{id:"撤销更改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#撤销更改"}},[t._v("#")]),t._v(" 撤销更改")]),t._v(" "),a("ul",[a("li",[t._v("尚未增加文件到暂存区：\n修改test.txt\ngit is a version control system.\ngit is free software.\ngit is good\ngit is easy to use\ngit is really useful\nboss is stupid\n撤销修改 -- 将文件恢复到最近一次add 或 commit之前的状态\ngit checkout -- test.txt")]),t._v(" "),a("li",[t._v("已经增加文件到暂存区，但尚未提交到分支：\n修改test.txt\ngit is a version control system.\ngit is free software.\ngit is good\ngit is easy to use\ngit is really useful\nboss is stupid\n增加文件到暂存区：\ngit add\n撤销修改 -- 把暂存区的修改撤销掉\ngit reset HEAD test.txt\n撤销修改 -- 将文件恢复到最近一次add 或 commit之前的状态\ngit checkout -- test.txt")]),t._v(" "),a("li",[t._v("但这仅限于本地版本库，如果版本已经提交到远程版本库，则即使在本地做版本库中做回退，也无法取消在远程版本库中的记录。")])]),t._v(" "),a("h2",{attrs:{id:"删除文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除文件"}},[t._v("#")]),t._v(" 删除文件")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("从工作区中删除文件\nrm test.txt\n查看版本库状态\ngit status\t\n增加删除文件操作到暂存区：\ngit rm test.txt\n提交版本到分支\ngit commit -m “描述”")])]),t._v(" "),a("li",[a("p",[t._v("细节:Git跟踪并管理的是修改，而非文件。")])])]),t._v(" "),a("h2",{attrs:{id:"github远程仓库连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#github远程仓库连接"}},[t._v("#")]),t._v(" GitHub远程仓库连接")]),t._v(" "),a("ul",[a("li",[t._v('创建SSH Key\n$ ssh-keygen -t rsa -C "youremail@example.com"\n最终，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容')])]),t._v(" "),a("h2",{attrs:{id:"关联远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关联远程仓库"}},[t._v("#")]),t._v(" 关联远程仓库")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("本地关联到远程仓库：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" $ git remote add origin git@github.com:piaoqian/learngit.git\n")])])])])]),t._v(" "),a("h2",{attrs:{id:"推送到远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推送到远程仓库"}},[t._v("#")]),t._v(" 推送到远程仓库")]),t._v(" "),a("ul",[a("li",[t._v("把本地库的内容推送到远程:\n$ git push -u origin master")]),t._v(" "),a("li",[t._v("第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n$ git push origin master")])]),t._v(" "),a("h2",{attrs:{id:"从远程仓库克隆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从远程仓库克隆"}},[t._v("#")]),t._v(" 从远程仓库克隆")]),t._v(" "),a("p",[t._v("$ git clone git@github.com:piaoqian/gitskills.git")]),t._v(" "),a("h2",{attrs:{id:"拉取版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拉取版本"}},[t._v("#")]),t._v(" 拉取版本")]),t._v(" "),a("p",[t._v("$ git pull <远程主机名> <远程分支名>:<本地分支名>")]),t._v(" "),a("h2",{attrs:{id:"删除远程仓库关联"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除远程仓库关联"}},[t._v("#")]),t._v(" 删除远程仓库关联")]),t._v(" "),a("p",[t._v("$git remote rm origin")]),t._v(" "),a("h2",{attrs:{id:"分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支"}},[t._v("#")]),t._v(" 分支")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("创建分支：\n$ git branch dev")])]),t._v(" "),a("li",[a("p",[t._v("$ git checkout dev")])]),t._v(" "),a("li",[a("p",[t._v("或\n$ git checkout -b dev   //-b参数表示创建并切换")])]),t._v(" "),a("li",[a("p",[t._v("用git branch命令查看当前分支:\n$git branch")])]),t._v(" "),a("li",[a("p",[t._v("创建文件：\ntest2.txt\ncreating a new branch is quick.")])]),t._v(" "),a("li",[a("p",[t._v("提交：\n$ git add test2.txt")])]),t._v(" "),a("li",[a("p",[t._v('$ git commit -m "branch test"')])]),t._v(" "),a("li",[a("p",[t._v("切换回主分支\n$git checkout master0")])]),t._v(" "),a("li",[a("p",[t._v("把dev分支的工作成果合并到master分支上。git merge命令用于合并指定分支到当前分支。此时采用的是快速合并策略。\n$git merge dev0")])]),t._v(" "),a("li",[a("p",[t._v("合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n删除dev分支:\n$ git branch -d dev")])]),t._v(" "),a("li",[a("p",[t._v("查看branch：\n$ git branch")])])]),t._v(" "),a("h3",{attrs:{id:"分支之间合并冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支之间合并冲突"}},[t._v("#")]),t._v(" 分支之间合并冲突")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当多个分支之间的进行合并时，可能会产生冲突，需要对冲突解决后才能合并分支\n创建新的分支feature1\n$ git checkout -b feature1")])]),t._v(" "),a("li",[a("p",[t._v("修改文件:\t\t\ntest2.txt\ncreating a new branch is quick and simple.\n在feature1分支上提交:\t\t\n$ git add test2.txt")])]),t._v(" "),a("li",[a("p",[t._v('git commit -m "AND simple"\n切换到master分支：\n$ git checkout master')])]),t._v(" "),a("li",[a("p",[t._v("修改文件：\ntest2.txt\nCreating a new branch is quick & simple.")])]),t._v(" "),a("li",[a("p",[t._v("在master分支上提交:\t\t\n$ git add test2.txt")])]),t._v(" "),a("li",[a("p",[t._v('$ git commit -m "& simple"')])]),t._v(" "),a("li",[a("p",[t._v("这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突：\n$ git merge feature1")])]),t._v(" "),a("li",[a("p",[t._v("Git告诉我们，test2.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：\n$ git status\n修改如下后保存：\nCreating a new branch is quick and simple.")])]),t._v(" "),a("li",[a("p",[t._v("再提交:\n$ git add test2.txt")])]),t._v(" "),a("li",[a("p",[t._v('$ git commit -m "conflict fixed"\n用带参数的git log也可以看到分支的合并情况：')])]),t._v(" "),a("li",[a("p",[t._v("$ git log --graph --abbrev-commit --pretty=oneline")])]),t._v(" "),a("li",[a("p",[t._v("最后，删除feature1分支：\n$ git branch -d feature1\n冲突解决。")])])]),t._v(" "),a("h3",{attrs:{id:"stash暂存分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stash暂存分支"}},[t._v("#")]),t._v(" stash暂存分支")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当某一分支工作到一半，突然需要切换到其他分支时，可以通过stash机制将当前分支状态暂存起来，再在需要的时候恢复。\n创建新的分支dev\n$ git checkout -b dev")])]),t._v(" "),a("li",[a("p",[t._v("修改文件:\t\t\ntest3.txt\ntoday is a good day.\n加入文件：")])]),t._v(" "),a("li",[a("p",[t._v("$ git add test3.txt\n临时需要切换到其他分支，暂存当前分支：")])]),t._v(" "),a("li",[a("p",[t._v("$ git stash\n查看状态：")])]),t._v(" "),a("li",[a("p",[t._v("$ git status\n切换到dev2分支")])]),t._v(" "),a("li",[a("p",[t._v("$ git checkout master")])]),t._v(" "),a("li",[a("p",[t._v("$ git checkout -b dev2")])]),t._v(" "),a("li",[a("p",[t._v("修改文件：\ntest4.txt")])]),t._v(" "),a("li",[a("p",[t._v("happy every day\n加入文件：")])]),t._v(" "),a("li",[a("p",[t._v("$ git add test4.txt\n提交文件：")])]),t._v(" "),a("li",[a("p",[t._v('$ git commit test4.txt -m "add test4.txt"\n切换到master分支')])]),t._v(" "),a("li",[a("p",[t._v("$ git checkout master\t\t\n合并分支")])]),t._v(" "),a("li",[a("p",[t._v('$ git merge --no-ff -m "merged dev2" dev2')])]),t._v(" "),a("li",[a("p",[t._v("切换回dev分支：\n$ git checkout dev")])]),t._v(" "),a("li",[a("p",[t._v("$ git status\n发现工作区是干净的，需要恢复暂存分支：")])]),t._v(" "),a("li",[a("p",[t._v("$ git stash list\n有两个办法：")])]),t._v(" "),a("li",[a("p",[t._v("一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n另一种方式是用git stash pop，恢复的同时把stash内容也删\t\n$ git stash pop")])])]),t._v(" "),a("h2",{attrs:{id:"多人协作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多人协作"}},[t._v("#")]),t._v(" 多人协作")]),t._v(" "),a("ul",[a("li",[t._v("在多人使用远程仓库进行工作时，往往在同一个分支上的操作会存在冲突，此时需要远程冲突合并。\n多人协作的工作模式通常是这样：\n首先，可以试图用git push origin "),a("branch-name",[t._v("推送自己的修改；\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n如果合并有冲突，则解决冲突，并在本地提交；\n没有冲突或者解决掉冲突后，再用git push origin "),a("branch-name",[t._v("推送就能成功！\n如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to "),a("branch-name",[t._v(" origin/"),a("branch-name")],1)],1)],1)],1)]),t._v(" "),a("h2",{attrs:{id:"标签"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标签"}},[t._v("#")]),t._v(" 标签")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("git中的版本都有版本编号，对代码的提交和回滚都是基于版本编号进行的，但是git中的版本编号是一串随机串，不好记忆，此时可以使用标签机制为某个提交增加标签，方便以后查找\n在当前分支当前提交上打标签：\n$git tag v1.0\t\n查看所有标签,默认标签是打在最新提交的commit上的：")])]),t._v(" "),a("li",[a("p",[t._v("$git tag\n如果想要打标签在某个指定历史commit上：")])]),t._v(" "),a("li",[a("p",[t._v("$ git tag v0.9 f52c633\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：")])]),t._v(" "),a("li",[a("p",[t._v('$ git tag -a v0.1 -m "version 0.1 released" 1094adb\n可以通过如下命令查看一个tag信息：')])]),t._v(" "),a("li",[a("p",[t._v("$ git show v0.1")])]),t._v(" "),a("li",[a("p",[t._v("如果标签打错了，也可以删除：\n$ git tag -d v0.1")])]),t._v(" "),a("li",[a("p",[t._v("如果要推送某个标签到远程，使用命令git push origin "),a("tagname",[t._v("：\n$ git push origin v1.0")])],1)]),t._v(" "),a("li",[a("p",[t._v("或者，一次性推送全部尚未推送到远程的本地标签：\n$ git push origin --tags")])]),t._v(" "),a("li",[a("p",[t._v("如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n$ git tag -d v0.9")])]),t._v(" "),a("li",[a("p",[t._v("然后，从远程删除。删除命令也是push，但是格式如下：\n$ git push origin :refs/tags/v0.9")])])]),t._v(" "),a("h2",{attrs:{id:"别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#别名"}},[t._v("#")]),t._v(" 别名")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("配置别名：\n$ git config --global alias.st status")])]),t._v(" "),a("li",[a("p",[t._v("$ git config --global alias.co checkout")])]),t._v(" "),a("li",[a("p",[t._v("$ git config --global alias.ci commit")])]),t._v(" "),a("li",[a("p",[t._v("$ git config --global alias.br branch")])]),t._v(" "),a("li",[a("p",[t._v("删除别名:\n找到[user_dir]/.gitconfig 文件\n找到[alias]标签，删除其中别名")])])])])}),[],!1,null,null,null);i.default=e.exports}}]);